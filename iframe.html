<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="robots" content="noindex, nofollow">
    <meta name="googlebot" content="noindex, nofollow">
    <script type="text/javascript" src="js/jquery-2.2.4.min.js"></script>
    <link rel="stylesheet" type="text/css" href="css/result-light.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
            crossorigin="anonymous"></script>
    <title>Ice Breaker</title>


    <script type='text/javascript'>
		var bearImage = new Image();		
		bearImage.src = "pics/polar_bears.png";
		
		var iceBlock = new Image();		
		iceBlock.src = "pics/ice_block.png";
		
		var goneIce = new Image();		
		goneIce.src = "pics/gone_block.png";
		
		var weakBlock = new Image();
		weakBlock.src = "pics/weak_block.png";
		
		var hitBlock = new Image();
		hitBlock.src = "pics/blocks_that_will_be_hit.png";
		
		var ctx;
		var gridSize;
		var	playerOneName
		var	playerTwoName		
		var rawGridSize;				
		var stage = 0;
		var turnNumber = 0;		
		var bear_rows;
		var bear_cols;		
		var bearLocation = [];
		var currClicked = [];
		var brokenIce = [];
		var weakIce = [];		
		var bearLocationLength = -1;		
		var board = {};
		
		var CONST_BLOCK_SIZE = 40;
		var CONST_MAX_HIT_HIGHLIGHT = 4;

		//this function is used to draw the board
        function drawBackground(context) {
            context.beginPath();
            for (var x = 0; x <= gridSize; x += CONST_BLOCK_SIZE) {
                context.moveTo(x, 0);
                context.lineTo(x, gridSize);
            }
            for (var x = 0; x <= gridSize; x += CONST_BLOCK_SIZE) {
                context.moveTo(0, x);
                context.lineTo(gridSize, x);
            }
            context.strokeStyle = "black";
            context.stroke();
        }
        		
		function getCoordinatesValue(val)
		{
			return Math.floor(val / CONST_BLOCK_SIZE);
		}				

		//this is for turn 1 where player 1 will make the bear placement.
        function handleClickPhase0(e) {
			
            mouseX = parseInt(e.pageX - offsetX);
            mouseY = parseInt(e.pageY - offsetY);
			
			x = getCoordinatesValue(parseInt(e.pageX - offsetX));
			y = getCoordinatesValue(parseInt(e.pageY - offsetY));
						
			
			var removeIndex = -1;
			var currClickedLength = currClicked.length;

			//if the block clicked was already marked as clicked, this will mark it as not clicked and remove from currClicked
			for (var i = 0; i < currClickedLength; ++i)
			{
				var currClickedLoc = currClicked[i];
				
				if (currClickedLoc[0] === x && currClickedLoc[1] === y)
				{
					ctx.drawImage(iceBlock, x * CONST_BLOCK_SIZE, y * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
					removeIndex = i;
					break;
				}
			}			
						
			if (removeIndex >= 0)
			{
				currClicked.splice(removeIndex, 1);
				return;
			}			
			
			if (currClicked.length >= CONST_MAX_HIT_HIGHLIGHT)
			{
				alert("You already have selected 4 blocks!");
				return;
			}		
					
			currClicked.push([x, y]);           
			ctx.drawImage(hitBlock, x * CONST_BLOCK_SIZE, y * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
        }

		//this is for after bear placement phase is done
        function handleClickPhase1(e) {	
            mouseX = parseInt(e.pageX - offsetX);
            mouseY = parseInt(e.pageY - offsetY);
			
			x = getCoordinatesValue(parseInt(e.pageX - offsetX));
			y = getCoordinatesValue(parseInt(e.pageY - offsetY));
						
			var removeIndex = -1;
			var currClickedLength = currClicked.length;
			
			//if the block clicked was already marked as clicked, this will mark it as not clicked and remove from currClicked
			for (var i = 0; i < currClickedLength; ++i)
			{
				var currClickedLoc = currClicked[i];
				
				if (currClickedLoc[0] === x && currClickedLoc[1] === y)
				{
					ctx.drawImage(iceBlock, x * CONST_BLOCK_SIZE, y * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
					removeIndex = i;
					break;
				}
			}			
						
			if (removeIndex >= 0)
			{
				currClicked.splice(removeIndex, 1);
				return;
			}						
			
			if (currClicked.length >= CONST_MAX_HIT_HIGHLIGHT)
			{				
				alert("You already have selected 4 blocks!");
				return;
			}		
					
			//bearLocationLength will be 4 at this point
			for (var i = 0; i < bearLocationLength; ++i)
			{
				var currBearLoc = bearLocation[i];
				
				if (currBearLoc[0] === x && currBearLoc[1] === y)
				{
					return; //bear clicked, should not do anything
				}
			}			
						
			var brokenIceLength = brokenIce.length;
						
			for (var i = 0; i < brokenIceLength; ++i)
			{
				var currBrokenLoc = brokenIce[i];
				
				if (currBrokenLoc[0] === x && currBrokenLoc[1] === y)
				{
					return; //broken ice clicked, should not do anything
				}
			}						
						
			currClicked.push([x, y]);           
			ctx.drawImage(hitBlock, x * CONST_BLOCK_SIZE, y * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
        }

		//binds the handlers
        function startGame() {
		
            $("#canvas").contextmenu(function (e) {                
                return false;
            });

            $("#canvas").click(function (f) {
				
                if (stage == 0) {
                    handleClickPhase0(f);
                }
                if (stage == 1) {
				
                    handleClickPhase1(f);
                }
            });
        }
  
        $(function () {
            $('#firstButton').popover({
                container: "body",
                html: true,
                content: function () {

                    return $('#message').html();
                    ;
                }

            })
        });
		
		//resets game state
        function resetGame() {            
            var submitButton = document.getElementById("submit");
			submitButton.disabled = false;
			submitButton.style.display = 'block';
			
			var confirmButton = document.getElementById("confirm");
			confirmButton.disabled = true;
			confirmButton.style.display = 'none';			
			
			var parent = document.getElementById("inner");
            var child = document.getElementById("canvas");
            parent.removeChild(child);
            var reset = document.getElementById('reset');
            reset.style.display = "none";
			
			var playerIdDisplay = document.getElementById('playerIdDisplay');
			//var moveCountDisplay = document.getElementById('moveCountDisplay');
			
			var div = document.getElementById("inner");
			div.removeChild(playerIdDisplay);
			//div.removeChild(moveCountDisplay);
			
			document.getElementById("grid-size").disabled = false;
			document.getElementById("player1_name").disabled = false;
			document.getElementById("player2_name").disabled = false;				
						
			stage = 0;
			turnNumber = 0;		
			bearLocation = [];
			currClicked = [];
			brokenIce = [];
			weakIce = [];		
			bearLocationLength = -1;		
			board = {};			
			
        }
		
		function initMask(size){
			//new Array

			var mask = new Array(size);
			
			//Iter subarrays
			for (var i = 0; i < size; i++){
				mask[i] = new Array(size);
				for (var j = 0; j < size; j ++){
					mask[i][j] = 1;
				}
			}
			
			return (mask);
		}

		//Missing Pieces
		function combinations(mask){
			//Init row and cols sums arrays
			var rowSums = Array.apply(null, Array(mask.length)).map(Number.prototype.valueOf,0);
			var colSums = Array.apply(null, Array(mask.length)).map(Number.prototype.valueOf,0);
			
			//Iter through mask
			for (var i = 0; i < mask.length; i++){
				for (var j = 0; j < mask.length; j++){
					rowSums[i] += mask[i][j];
					colSums[j] += mask[i][j];
				}
			}
			
			//Create 2d array pairings of values
			var sums = rowSums.reduce( (a, v) => [...a, ...colSums.map(x=>[v,x])], []);
			var indices = [];
			
			//Values to indices
			for (var i = 0; i < sums.length; i++){
				if ((sums[i][0] != mask.length) && (sums[i][1] != mask.length)){
					indices.push([Math.floor(i/mask.length), i % mask.length]);
				}
			}
			
			return (indices);
		}


		function flipAxes(currClicked){
			var hits = new Array(currClicked.length);
			for (var i = 0; i < currClicked.length; i++){
				hits[i] = new Array(2);
				hits[i][0] = currClicked[i][1];
				hits[i][1] = currClicked[i][0];
			}
			return (hits);
		}

		//Update board
		function updateMask(board, currClicked){
			//Temp board
			var new_mask = copy(board.mask);
			var hits = flipAxes(currClicked);
		   //Update board for hits
		   for (var i = 0; i < hits.length; i++){
			   new_mask[hits[i][0]][hits[i][1]] = 0;
		   }
		   
		   //Other blocks to remove
		   var indices = combinations(new_mask);
		   
		   //Update board
		   for (var i = 0; i < indices.length; i++){
			   var ix = indices[i][0];
			   var iy = indices[i][1];
			   new_mask[ix][iy] = 0;
		   }

		   var state = bearStatus(new_mask, bear_rows, bear_cols);

		   new_board = {"state":state,
						"mask":new_mask
					   }

			console.log("new_board", new_board);

		   return (new_board);
		}		
		
		function getIndices(arr, ind){
			//Init arr
			var ind_arr = Array.apply(null, Array(arr.length)).map(Number.prototype.valueOf,0);
			//Get ind from each subarray
			for (var i = 0; i < arr.length; i++){
				ind_arr[i] = arr[i][ind];
			}
			//Unique indices
			var ind_arr_uniq = Array.from(new Set(ind_arr));
			return (ind_arr_uniq);
		}

		function copy(obj) {
			if (!obj) {
			  return obj;
			}
		  
			let v;
			let obj2 = Array.isArray(obj) ? [] : {};
			for (const k in obj) {
			  v = obj[k];
			  obj2[k] = (typeof v === "object") ? copy(v) : v;
			}
		  
			return obj2;
		}

		//Bear Status
		function bearStatus(mask, bear_rows, bear_cols){
			var rowSums = Array.apply(null, Array(bear_rows.length)).map(Number.prototype.valueOf,0);
			var colSums = Array.apply(null, Array(bear_cols.length)).map(Number.prototype.valueOf,0);

			//Iter through Bear rows
			for (var i = 0; i < bear_rows.length; i++){
				for (var j = 0; j < mask.length; j++){
					rowSums[i] += mask[bear_rows[i]][j];
				}
			}
			
			//Iter through Bear cols
			for (var i = 0; i < mask.length; i++){
				for (var j = 0; j < bear_cols.length; j++){
					colSums[j] += mask[i][bear_cols[j]];
				}
			} 
			
			//Concat
			var sums = rowSums.concat(colSums);
			//Count how many are broken
			var counts = 0;
			for (var i = 0; i < sums.length; i++){
				if (sums[i] != mask.length){
					counts++;
				}
			}
			if (counts == sums.length){
				return (0);
			} else {
				return (1);
			}
			
		}		
	
		//checks if the given coordinate is part of the 2x2 bear cluster
		function checkIsBearLocation(x, y)
		{
			for (var bearIndex = 0; bearIndex < bearLocationLength; ++bearIndex)
			{
				var currBearLoc = bearLocation[bearIndex];
											
				if (currBearLoc[0] === x && currBearLoc[1] === y)
				{
					return true;
				}							
			}		
		
			return false;
		}
				
		//will be called after calculation has been done to see the grid state
		function paintGrid(newGrid)
		{
			brokenIce = [];
			
			//this will represent y coordinate			
			for (var i = 0; i < rawGridSize; ++i)
			{
				//this will represent x coordinate
				for (var j = 0; j < rawGridSize; ++j)
				{
					if (newGrid[i][j] === 1)
					{
						var isBear = false;
					
						if (checkIsBearLocation(j, i))
						{
							ctx.drawImage(bearImage, j * CONST_BLOCK_SIZE, i * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
						}
						else
						{
							ctx.drawImage(iceBlock, j * CONST_BLOCK_SIZE, i * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
						}					
					}
					else
					{
						if (checkIsBearLocation(j, i))
						{
							ctx.drawImage(bearImage, j * CONST_BLOCK_SIZE, i * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
						}
						else
						{
							brokenIce.push([j, i]);
							ctx.drawImage(goneIce, j * CONST_BLOCK_SIZE, i * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);						
						}
					}
				}
			}
		}
		
		//check if the block hit values are valid
		function checkBlockHit()
		{
			if (stage === 0)
			{
				if (currClicked.length !== CONST_MAX_HIT_HIGHLIGHT)
				{
					alert("You must place the bears in a 2x2 block formation!");
					return false;
				}
				
				var tmp_rows = getIndices(currClicked, 0);
				var tmp_cols = getIndices(currClicked, 1);

				if (tmp_rows.length !== 2 || tmp_cols.length !== 2)
				{
					alert("You must place the bears in a 2x2 block formation!");
					return false;
				}
				
				return true;
			}
			else
			{
				var currClickedLength = currClicked.length;
			
				if (currClickedLength === 0)
				{
					alert("You must hit something!");
					return false;
				}
				else if (currClickedLength > CONST_MAX_HIT_HIGHLIGHT)
				{
					alert("You can only hit at most 4 pieces in a 2x2 block!");
					return false;
				}
								
				if (currClickedLength > 1)
				{
					var end = currClickedLength - 1;
					
					while (end > 0)
					{
						for (var i = 0; i < end; ++i)
						{
							if (Math.abs(currClicked[i][0] - currClicked[end][0]) > 1 || Math.abs(currClicked[i][1] - currClicked[end][1]) > 1)
							{
								alert("You can only hit at most 4 pieces in a 2x2 block!");
								return false;						
							}
						}

						--end;
					}					
				}
				
				return true;
			}
		}
						
		//game start with the player names and grid size
		function confirmClicked()
		{
			//at bear setting stage
			if (stage === 0)
			{
				if (!checkBlockHit())
				{					
					return;
				}
				
				bearLocation = currClicked;
				bearLocationLength = bearLocation.length;
				
				bear_rows = getIndices(bearLocation, 1);
				bear_cols = getIndices(bearLocation, 0);						
				
				//should be 4, but we can use bearLocation.length for scalability.
				var bearLength = bearLocation.length;
				
				for (var i = 0; i < bearLength; ++i)
				{
					ctx.drawImage(bearImage, bearLocation[i][0] * CONST_BLOCK_SIZE, bearLocation[i][1] * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
				}
								
				stage = 1;
				turnNumber++;
				currClicked = [];
				
				if (turnNumber % 2 === 0)
				{
					$(playerIdDisplay).html("Current player: " + playerOneName);
				}
				else
				{
					$(playerIdDisplay).html("Current player: " + playerTwoName);
				}
			}
			else
			{
				//Check valid input
				if (!checkBlockHit())
				{
					return;
				}		
				
				var newBoard = updateMask(board, currClicked);
				
				board = newBoard
				
				//given the results, repaint map and update coor;								
				paintGrid(newBoard.mask);
				
				if (newBoard.state === 0)
				{
					//game over
					stage = 2;
					
					$(playerIdDisplay).html("Game Over!");
					
					if (turnNumber % 2 === 0)
					{
						alert("Player 1 disturbed the bears and is going to jail; Player 2 wins!")
						
					}
					else
					{
						alert("Player 2 disturbed the bears and is going to jail; Player 1 wins!")
					}					
					
					var confirmButton = document.getElementById("confirm");
					confirmButton.disabled = true;
					confirmButton.style.display = 'none';							
					
					return;					
				}
				
				turnNumber++;
				currClicked = [];						
				
				if (turnNumber % 2 === 0)
				{
					$(playerIdDisplay).html("Current player: " + playerOneName);
				}
				else
				{
					$(playerIdDisplay).html("Current player: " + playerTwoName);
				}				
								
			}
			
			//check if valid, if so, increment turns, and then send backend
		}
		
		//called after submit is clicked. Make sure the given parameters are correct and initialize the next stage
        function verifyAndStart() 
		{
            gridSize = document.getElementById("grid-size").value;
			playerOneName = document.getElementById("player1_name").value;
			playerTwoName = document.getElementById("player2_name").value;
			rawGridSize = gridSize;
           			
			if (isValidInput(gridSize))
			{
                var reset = document.getElementById('reset');
                reset.style.display = "block";
				
				gridSize = gridSize * CONST_BLOCK_SIZE;
                var reset = document.getElementById('reset');
                
                canvas = document.createElement("canvas");
                canvas.id = "canvas";
                canvas.width = gridSize;
                canvas.height = gridSize;
                var div = document.getElementById("inner");
                div.appendChild(canvas);				
				
				var submitButton = document.getElementById("submit");
                submitButton.disabled = true;
				submitButton.style.display = 'none';
				
				var confirmButton = document.getElementById("confirm");
				confirmButton.disabled = false;
				confirmButton.style.display = 'block';						
				
                document.getElementById("grid-size").disabled = true;
				document.getElementById("player1_name").disabled = true;
				document.getElementById("player2_name").disabled = true;				
				
                ctx = canvas.getContext("2d");
                canvasOffset = $("#canvas").offset();
                offsetX = canvasOffset.left;
                offsetY = canvasOffset.top;				
				
                drawBackground(ctx);
                
                stage = 0;
				board = {"state": 1, "mask": initMask(rawGridSize)};
				
                var playerIdDisplay = document.createElement("h4");
                playerIdDisplay.id = "playerIdDisplay";
                playerIdDisplay.class = "text-primary";			

                $(playerIdDisplay).html("Player 1 will choose a 2x2 block where the bears are located.");

                var div = document.getElementById("inner");
                div.appendChild(playerIdDisplay);		
				
				startGame();

				for (var i = 0; i < gridSize; ++i)
				{
					for (var j = 0; j < gridSize; ++j)
					{
						ctx.drawImage(iceBlock, i * CONST_BLOCK_SIZE, j * CONST_BLOCK_SIZE, CONST_BLOCK_SIZE, CONST_BLOCK_SIZE);
					}
				}
			}
			else {
                alert("Invalid input")
            }
        }

        function isValidInput(x) {
            if (isNaN(x) || x < 5 || x > 12) {
                return false;
            } else {
                return true;
            }
        }

    </script>


</head>

<body>

<div id="topTitle">
    <h1>***FREE*** ICE BREAKER (only 5 annual payments of $0.00)</h1>
    <br>
    <br>
</div>
<div class="wrapper" id="wrapper" style="margin: auto; width: 95%; position: absolute;">
    <div id="outer" style="text-align: center; position:absolute; width:65%">
        <div id="inner" style="display: inline-block;">

        </div>
    </div>


    <div class="form-group" id="RightPane" style="position: absolute; top:0; left: 70%; width:30%">
        <a id="firstButton" class="btn btn-default" rel="popover" data-placement="bottom"
           data-message="Message">Instructions</a>

        <h2>Controls</h2>


        <br>

        Enter the size of the square grid (5 to 12): <input type="text" id="grid-size" value="6" class="form-control"
                                                  required style=";margin: 5px"><br>
        <br>
		
        <br>

        Enter Player 1 name: <input type="text" id="player1_name" value="Foo" class="form-control"
                                                  required style=";margin: 5px"><br>
        <br>

        <br>

        Enter Player 2 name: <input type="text" id="player2_name" value="Bar" class="form-control"
                                                  required style=";margin: 5px"><br>
        <br>		


        <button type="button" id="submit" class="btn btn-primary" style=";margin: 5px" onclick="verifyAndStart()">
            Submit</button>
		<button type="button" id="confirm" class="btn btn-primary" disabled=true visibility='hidden' style="display:none;margin: 5px" onclick="confirmClicked()">
            Confirm</button>
        <button type="button" id="reset" class="btn btn-primary" onclick="resetGame()"
                style="float: right;display: none;margin: 5px;">Start over!
        </button>
        <button type="button" id="restart" class="btn btn-primary" onclick="restartGame()"
                style="float: right;display: none;margin: 5px">Try again!
        </button>
        <br>
        <br>
        <button type="button" id="ConfirmMines" class="btn btn-primary" disabled=true onclick="confirmMines()" visibility='hidden'
                style="display:none;margin: 5px">Confirm Mines
        </button>
        <button type="button" id="RandomMines" class="btn btn-primary" disabled=true onclick="randomMines()" visibility='hidden'
                style="display:none;margin: 5px"> Generate random mines
        </button>


        <div id="message" style="display:none;">
            <b>Rules</b>            
			<br>
            You are on a trip to break some ice in order to clear the area to build a new vacation resort in Antarctica. The area contains magically floating ice blocks in a 6x6 grid. The ice block can only float if it is in a row or column that has all the ice blocks intact. In addition, there is a group of endangered polar bears sitting in a 2x2 ice block somewhere on the grid (player 1 gets to choose that location). Since they are protected animals, you must not disturb the bears; otherwise, you go to jail! The polar bear will move away if the 2x2 falls. Luckily, your arch-nemesis is also there to help you clear the ice for the resort. You both decide to have a "friendly" wager that will send the loser to jail. Each person will take turns knocking down the ice blocks. You can either hit only one block, or hit the intersections of blocks in order to knock some or all of them down (you can choose between 1 to 4 blocks based on the intersections). Both of you have perfect accuracy in terms of hitting the ice because you both went to NYU on an ice-breaking scholarship, courtesy of the Global Warming Group, and got your PhD in ice breaking. Good luck!
                      
        </div>


        <br><br>


    </div>


</div>

</body>

</html>

